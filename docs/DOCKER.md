# Docker

1N4 can be built and run using Docker.
Other containerization tools like Podman would probably work,
but we have not tested them.
There's a few different ways of building the image and running the container,
but they all share the same emulation requirements if you're cross-compiling to another platform.

If a different target CPU architecture is chosen for the target platform,
Rust will cross-compile for that architecture from a native container.
The last build step that puts the image together still relies on emulating the target architecture, however.
[Docker's documentation](https://docs.docker.com/build/building/multi-platform/#qemu) points towards [`tonistiigi/binfmt`](https://github.com/tonistiigi/binfmt)
as being the easy option to set up QEMU for this,
but your package manager may provide its own packages if you prefer that.
For example, one can set up emulation on Ubuntu 24.04 (and probably other Debian derivatives) like so:

```sh
apt install 'binfmt-support' 'qemu-user-static'

qemu_ref='master' # Or set to a specific version, e.g., `v8.2.2`.
curl --fail --show-error --location --remote-name \
    "https://raw.githubusercontent.com/qemu/qemu/refs/heads/$qemu_ref/scripts/qemu-binfmt-conf.sh"
chmod u+x './qemu-binfmt-conf.sh'

# Registers the interpreters with the Kernel. Will have to be repeated every
# reboot.
#
# `./qemu-binfmt-conf.sh --help` for more information on this command and the
# other options you can enable.
./qemu-binfmt-conf.sh --qemu-suffix '-static' --qemu-path '/usr/bin' \
    --persistent 'yes'

# Registers every interpreter at startup with a systemd service. You can also
# specify individual CPU architectures to register, `ALL` registers every
# architecture supported by QEMU.
# 
# The systemd service is disabled by default on WSL to protect the interpreter
# it registers for Windows binaries, so WSL users will either have to run the
# command above on every reboot or use the Debian-specific solution below (for
# Debian-based distributions). For more information on why WSL does this, refer
# to the documentation:
#
# - <https://documentation.ubuntu.com/wsl/latest/explanation/binfmt/>
# - <https://wsl.dev/technical-documentation/interop/>
./qemu-binfmt-conf.sh --qemu-suffix '-static' --qemu-path '/usr/bin' \
    --persistent 'yes' \
    --systemd 'ALL'

# To register the emulators on every boot. Exclusive to Debian-based systems
# with `update-binfmts` (provided on Ubuntu by the package `binfmt-support`).
./qemu-binfmt-conf.sh --qemu-suffix '-static' --qemu-path '/usr/bin' \
    --persistent 'yes' \
    --debian
# Actually register the templates generated by the script.
for template in /usr/share/binfmts/qemu-*; do
    update-binfmts --import "$template"
done
```

If all you want is easy and performant cross-compilation,
[`cross`](https://crates.io/crates/cross) may be a better fit for you
than 1N4's official Docker container.

## Docker Compose

You can also run 1N4 using just `docker compose up`.
This requires that `HOST_USER` be set in the environment (such as with another line in `.env`)
to your Unix user ID and group ID separated with a colon, such as `1002:1002`.

If 1N4 or the `Dockerfile` have changed since the image was built,
run with `docker compose up --build` to rebuild the image.
This uses Docker's built-in caching, so running it this way every time is fine too.

Besides adding a `command` field to `compose.yml`,
there's no way to configure 1N4 with this method,
because 1N4 only supports command-line arguments.
We plan on addressing this in the future by adding support for config files.

<https://docs.docker.com/compose/>

## Docker CLI

If you'd like to export the built image
or apply command-line arguments to the running container without editing `compose.yml`,
you can build the image and run the container manually:

```sh
# Build for the host platform.
docker buildx build --tag 'ArchitecturalDogSoftware/ina' .

# Or build for another target.
#
# Compiles for the Rust target triple `$TARGET_ARCH_RUST-unknown-linux-musl`.
docker buildx build --tag 'ArchitecturalDogSoftware/ina' \
    --platform 'arm64' --build-arg 'TARGET_ARCH_RUST=aarch64' \
    .

# Export the image to a tarball, if you'd like to run it on another machine.
#
# On said machine, use `docker image load --input 'ina.tar'` and continue with the following steps
# to run it or just use `docker compose up` without `--build`.
docker image save --platform 'arm64' --output 'ina.tar' \
    'ArchitecturalDogSoftware/ina'

# Give the user in the Docker container permissions to write to necessary
# directories. You can skip mounting `./log/` if you set `--no-file-logging`
# and use Docker's native logging facilities instead.
chown -R '10001:10001' './log' './res/data'

# Start the Docker container and attach the TTY.
#
# Instead of `--env-file`, you could manually set each of the required
# environment variables using `--env VAR=value`. You can also let 1N4 load
# environment variables from `.env` instead of Docker by mounting it:
# `--mount 'type=bind,source=./.env,target=/app/.env,readonly'`.
docker run --tty --rm\
    --env-file '.env' \
    --mount 'type=bind,source=./log,target=/app/log' \
    --mount 'type=bind,source=./res,target=/app/res,readonly' \
    --mount 'type=bind,source=./res/data,target=/app/res/data' \
    'ArchitecturalDogSoftware/ina'

# Reset ownership of the necessary directories back to the current user.
chown -R "$(id -u):$(id -g)" './log' './res/data'
```

<https://docs.docker.com/reference/cli/docker/>

## Bash Script

The same steps involved for CLI usage are also automated in a Bash script,
`./scripts/docker.sh`.
This is more convenient, though at the cost of control.

```sh
# Build and run.
./scripts/docker.sh build && ./scripts/docker.sh run

# All arguments after a `--` are passed directly to 1N4.
./scripts/docker.sh build && ./scripts/docker.sh run -- --help

# Build and export to a tarball, in this example cross-compiling to
# ARM64/AArch64 (Docker's name and Rust's name, respectively).
./scripts/docker.sh build --platform 'arm64:aarch64' &&
    ./scripts/docker.sh export --platform 'arm64' --output 'ina.tar'
```
