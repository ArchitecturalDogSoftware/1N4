// SPDX-License-Identifier: AGPL-3.0-or-later
//
// Copyright Â© 2025 RemasteredArch
//
// This file is part of 1N4.
//
// 1N4 is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public
// License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
// version.
//
// 1N4 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License along with 1N4. If not, see
// <https://www.gnu.org/licenses/>.

use proc_macro::TokenStream;
use proc_macro2::Span;
use quote::quote;
use syn::parse::{Parse, ParseStream};
use syn::spanned::Spanned;
use syn::{Error, Expr, Field, Fields, FieldsNamed, FieldsUnnamed, Ident, Meta, MetaList, Result, Token, Type};

/// Represents the tokens `default = EXPR`, where `EXPR` may be any [`Expr`]. This is used to generate an expression to
/// generate the default value of a struct field.
#[expect(dead_code, reason = "keeping dead fields in case a refactor needs them")]
struct DefaultEqExpr {
    /// The `default` token. Not actually an [`Ident`], but it's good enough.
    default: Ident,
    eq: Token![=],
    /// The expression that generates a default value.
    expr: Expr,
    /// The span of the original invocation tokens, running all the way from the start of [`Self::default`] to the end
    /// of [`Self::expr`].
    span: Span,
}

impl Parse for DefaultEqExpr {
    fn parse(input: ParseStream) -> Result<Self> {
        let span = input.span();

        let default = input.parse()?;
        let eq = input.parse()?;
        let expr = input.parse()?;

        Ok(Self { default, eq, expr, span })
    }
}

/// Represents the fields of a struct in a manner that can be used to generate conversions between it and its optional
/// forms.
pub struct FieldsWithDefaults {
    /// The [`Ident`] of the struct with non-[optional] fields.
    ///
    /// [optional]: `Option`
    pub ident: Ident,
    /// The [`Ident`] of the struct with [optional] fields.
    ///
    /// [optional]: `Option`
    pub optional_ident: Ident,
    pub fields: Vec<FieldWithDefault>,
}

impl FieldsWithDefaults {
    /// Generates a conversions between [`Self::ident`] and [`Self::optional_ident`].
    ///
    /// - Generates a [`From`] conversion for [`Self::optional_ident`] that just takes every field of [`Self::ident`] as
    ///   [`Some`].
    /// - Generates a method called `fill_defaults` on [`Self::optional_ident`] that fills [`None`] fields with the
    ///   value generated by each field's [`DefaultEqExpr::expr`].
    pub fn generate_conversions(&self) -> TokenStream {
        let Self { ident, optional_ident, fields } = self;

        let idents = fields.iter().map(|FieldWithDefault { ident, .. }| ident).collect::<Vec<_>>();
        let assign_with_filled_defaults =
            fields.iter().map(FieldWithDefault::generate_assignment_with_filled_default).collect::<Vec<_>>();

        quote! {
            impl ::std::convert::From<#ident> for #optional_ident {
                fn from(value: #ident) -> Self {
                    Self {
                        // Some field of type `Type`, this has two effects. For `Option<Type>`,
                        // this will be `Option::from(Type)`, which is just `Some(Type)`. For
                        // `OptionalType`, this will be `OptionalType::from(Type)`, which should be
                        // calling _this_ method as it was generated for `OptionalType`.
                        #( #idents: value.#idents.into() ),*
                    }
                }
            }

            impl #optional_ident {
                #[doc = ::std::concat!(
                    "Create a new [`",
                    ::std::stringify!( #ident ),
                    // TO-DO: this should be updated to reflect the new `OptionalType` form.
                    "`] by filling all [`None`][`::std::option::Option::None`] values with the provided default expression.",
                )]
                #[must_use]
                pub fn fill_defaults(self) -> #ident {
                    #ident {
                        #( #assign_with_filled_defaults ),*
                    }
                }

                /// Apply [`std::option::Option::or`] or [`Self::or`] to each field of [`Self`].
                #[must_use]
                pub fn or(self, optb: Self) -> Self {
                    Self {
                        // TO-DO: this is unhygienic.
                        #( #idents: self.#idents.or(optb.#idents) ),*
                    }
                }

                /// Apply [`std::option::Option::xor`] or [`Self::xor`] to each field of [`Self`].
                #[must_use]
                pub fn xor(self, optb: Self) -> Self {
                    Self {
                        // TO-DO: this is unhygienic.
                        #( #idents: self.#idents.xor(optb.#idents) ),*
                    }
                }
            }
        }
        .into()
    }
}

enum DefaultValueGenerator {
    /// An expression that generates a default value for a field, can be used in the form
    /// `optional_field.unwrap_or_else(|| #expr)`.
    ///
    /// Comes from [`DefaultEqExpr::expr`].
    Expr(Expr),
    /// An indication a default value for a field can be generated from some `optional_field` with
    /// `optional_field.fill_defaults()`.
    ///
    /// Comes from `#[option(flatten)]`.
    FillDefaults,
}

/// Represents a [`Field`] and an [`Expr`] that generates a default value for it.
pub struct FieldWithDefault {
    /// See [`Field::ident`].
    ident: Ident,
    default: DefaultValueGenerator,
}

impl FieldWithDefault {
    // TO-DO: these error docs are out-of-date, they should mention `#[option(flatten)]` and tuple
    // structs.
    /// Create a new [`Self`] from an arbitrary [`Field`].
    ///
    /// # Errors
    ///
    /// Returns an error if the provided [`Field`] does not have the `#[option(...)]` annotation or
    /// if it is malformed.
    pub fn new(field: &Field) -> Result<Self> {
        let option_attr_path = super::attr_paths::option();
        let Some(mut option_attr) = field.attrs.iter().find(|attr| attr.path() == &option_attr_path).cloned() else {
            return Err(Error::new(field.span(), "missing `#[option(...)]` annotation to provide default values"));
        };

        let Some(ident) = field.ident.clone() else {
            return Err(Error::new(field.span(), "`optional` does not support tuple structs"));
        };

        let default: DefaultValueGenerator = match &mut option_attr.meta {
            // Of the form `#[option(default = "STRING LITERAL")]`.
            Meta::NameValue(meta_name_value) => DefaultValueGenerator::Expr(meta_name_value.value.clone()),
            Meta::List(list) => {
                match list.tokens.to_string().as_str() {
                    // Of the form `#[option(default)]`.
                    //
                    // TO-DO: this is unhygienic.
                    "default" => DefaultValueGenerator::Expr(syn::parse_quote! { Default::default() }),
                    // Of the form `#[option(flatten)]`.
                    "flatten" => DefaultValueGenerator::FillDefaults,
                    // Of the form `#[option(default = EXPRESSION)]`.
                    _ => {
                        let DefaultEqExpr { expr, .. } = syn::parse(list.tokens.clone().into()).map_err(|_| {
                            Error::new(
                                field.span(),
                                "expected annotation in the form of `#[option(default)]`, `#[option(default = \
                                 EXPRESSION)]`, or `#[option(flatten)]",
                            )
                        })?;

                        DefaultValueGenerator::Expr(expr)
                    }
                }
            }
            // Of another form.
            other @ Meta::Path(_) => {
                return Err(Error::new(
                    other.span(),
                    "expected annotation in the form of `#[option(default)]`, `#[option(default = EXPRESSION)]`, or \
                     `#[option(flatten)]`",
                ));
            }
        };

        Ok(Self { ident, default })
    }

    fn generate_assignment_with_filled_default(&self) -> proc_macro2::TokenStream {
        let Self { ident, default } = self;
        let method = match default {
            DefaultValueGenerator::Expr(expr) => quote! { unwrap_or_else(|| #expr) },
            DefaultValueGenerator::FillDefaults => quote! { fill_defaults() },
        };

        quote! {
            #ident: self.#ident.#method
        }
    }
}

// TO-DO: should `#[serde(...)]` be kept on `#[option(flatten)]`? When should that be kept?
//
// TO-DO: should this return [`FieldsNamed`]? We don't support the other two types anyways, do we?
/// Transforms the input [`Fields`] for use in the optional struct.
///
/// - Strips all [annotations][`syn::Attribute`]. If `#[option(default ...)]` was present at all, this adds
///   `#[serde(default, skip_serializing_if = "::std::option::Option::is_none")]` (fields default to [`None`], the
///   actual default values are filled later).
/// - Changes the types from various `T` to `Option<T>`. This is _specifically_ `Option`, and not
///   `::std::option::Option`, because Clap finds optional fields by checking for [`Option`] on a strictly textual
///   basis.
///   - If `#[option(flatten)]` was present, this will treat make the field "optional" by instead renaming the
///     identifier `IDENT` to `OptionalIDENT`, e.g., the optional form of `::my_other_crate::Settings` is assumed to be
///     `::my_other_crate::OptionalSettings`, and there is assumed to be a method
///     `::my_other_crate::OptionalSettings::fill_defaults(&self) -> ::my_other_crate::Settings`.
pub fn fields_to_optional(fields: Fields) -> Fields {
    match fields {
        Fields::Named(FieldsNamed { brace_token, named }) => {
            Fields::Named(FieldsNamed { brace_token, named: named.into_iter().map(field_to_optional).collect() })
        }
        Fields::Unnamed(FieldsUnnamed { paren_token, unnamed }) => Fields::Unnamed(FieldsUnnamed {
            paren_token,
            unnamed: unnamed.into_iter().map(field_to_optional).collect(),
        }),
        Fields::Unit => Fields::Unit,
    }
}

// TO-DO: update docs to account for subcommand flattening support.
//
// TO-DO: this doesn't actually strip all annotations, does it? It only strips
// `#[option(flatten)]`.
/// Transforms a single input [`Field`] for use in the optional struct.
///
/// - Strips all [annotations][`syn::Attribute`]. If `#[option(...)]` was present at all, this adds `#[serde(default,
///   skip_serializing_if = "::std::option::Option::is_none")]` (fields default to [`None`], the actual default values
///   are filled later).
/// - Changes the type from some `T` to `Option<T>`. This is _specifically_ `Option`, and not `::std::option::Option`,
///   because Clap finds optional fields by checking for [`Option`] on a strictly textual basis.
fn field_to_optional(Field { mut attrs, vis, mutability, ident, colon_token, ty }: Field) -> Field {
    let mut is_flattend_subcommand = false;

    let option_attr_path = super::attr_paths::option();
    if let Some(option_attr) = attrs.iter_mut().find(|attr| attr.path() == &option_attr_path) {
        if let Meta::List(ref mut list) = option_attr.meta
            && list.tokens.to_string() == "flatten"
        {
            is_flattend_subcommand = true;
            list.path = super::attr_paths::command();
        } else {
            option_attr.meta = Meta::List(MetaList {
                path: super::attr_paths::serde(),
                delimiter: option_attr.meta.require_list().unwrap().delimiter.clone(),
                tokens: quote! {
                    default, skip_serializing_if = "::std::option::Option::is_none"
                },
            });
        }
    }

    let ty = if is_flattend_subcommand {
        self::rename_to_optional(ty)
    } else {
        Type::Path(
            syn::parse(
                quote! {
                    // This must be `Option<T>`, not `::std::option::Option<T>`, because Clap
                    // currently matches on `Option` (to infer that an argument is optional) on a
                    // strictly textual basis, it doesn't attempt to infer from the actual type.
                    //
                    // See:
                    //
                    // - <https://github.com/clap-rs/clap/issues/4636#issuecomment-1381969663>
                    // - <https://github.com/clap-rs/clap/issues/4626>
                    Option< #ty >
                }
                .into(),
            )
            .unwrap(),
        )
    };

    attrs.retain(|attr| attr.path() != &option_attr_path);

    Field { attrs, vis, mutability, ident, colon_token, ty }
}

// TO-DO: this will only ever return [`TypePath`]. Maybe we should just... return [`TypePath`]?
fn rename_to_optional(ty: Type) -> Type {
    match ty {
        Type::Path(mut type_path) => {
            let Some(last) = type_path.path.segments.last_mut() else {
                unreachable!("type paths must have at least one segment <https://doc.rust-lang.org/reference/paths.html#paths-in-types>");
            };

            let Ok(prefixed) = syn::parse_str(&format!("Optional{}", last.ident)) else {
                unreachable!("`Optional` + `MyValidIdent` = `OptionalMyValidIdent` should be valid");
            };
            last.ident = prefixed;

            type_path.into()
        }
        Type::Group(type_group) => self::rename_to_optional(*type_group.elem),
        Type::Paren(type_paren) => self::rename_to_optional(*type_paren.elem),
        Type::Ptr(type_ptr) => self::rename_to_optional(*type_ptr.elem),
        Type::Reference(type_reference) => self::rename_to_optional(*type_reference.elem),
        Type::Array(_)
        | Type::BareFn(_)
        | Type::ImplTrait(_)
        | Type::Infer(_)
        | Type::Macro(_)
        | Type::Never(_)
        | Type::Slice(_)
        | Type::TraitObject(_)
        | Type::Tuple(_)
        | Type::Verbatim(_)
        | _ => unimplemented!(),
    }
}
