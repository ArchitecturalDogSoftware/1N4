// SPDX-License-Identifier: AGPL-3.0-or-later
//
// Copyright Â© 2025 RemasteredArch
//
// This file is part of 1N4.
//
// 1N4 is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public
// License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
// version.
//
// 1N4 is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License along with 1N4. If not, see
// <https://www.gnu.org/licenses/>.

use proc_macro2::{Span, TokenStream};
use quote::{ToTokens, quote};
use syn::parse::{Parse, ParseStream};
use syn::spanned::Spanned;
use syn::{Error, Expr, Field, Fields, FieldsNamed, Ident, Meta, Result, Token, Type, TypePath};

/// Represents the tokens `default = EXPR`, where `EXPR` may be any [`Expr`]. This is used to generate an expression to
/// generate the default value of a struct field.
#[expect(dead_code, reason = "keeping dead fields in case a refactor needs them")]
struct DefaultEqExpr {
    /// The `default` token. Not actually an identifier, but it's good enough.
    default: Ident,
    /// The equal sign separating the two values.
    eq: Token![=],
    /// The expression that generates a default value.
    expr: Expr,
    /// The span of the original invocation tokens, running all the way from the start of [`Self::default`] to the end
    /// of [`Self::expr`].
    span: Span,
}

impl Parse for DefaultEqExpr {
    fn parse(input: ParseStream) -> Result<Self> {
        let span = input.span();

        let default = input.parse()?;
        let eq = input.parse()?;
        let expr = input.parse()?;

        Ok(Self { default, eq, expr, span })
    }
}

/// Represents the fields of a struct in a manner that can be used to generate conversions between it and its optional
/// forms.
pub struct FieldsWithDefaults {
    /// The identifier of the struct with non-[optional] fields.
    ///
    /// [optional]: `Option`
    pub ident: Ident,
    /// The identifier of the struct with [optional] fields.
    ///
    /// [optional]: `Option`
    pub optional_ident: Ident,
    /// The actual list of the struct's fields' identifiers and default value expressions.
    pub fields: Vec<FieldWithDefault>,
}

impl FieldsWithDefaults {
    /// Generates a list of `&& self. #field #method_call` for each `#field` in [`Self::fields`], where the ampersands
    /// (for logical `AND`) are not included for the first field and each `#method_call` is generated by
    /// `generate_method_call`.
    fn generate_field_comparisons(
        &self,
        generate_method_call: impl Fn(OptionalKind) -> TokenStream,
    ) -> Vec<TokenStream> {
        let mut is_first = true;
        self.fields
            .iter()
            .map(|FieldWithDefault { ident, default }| {
                let method_call = generate_method_call(match default {
                    DefaultValueGenerator::Expr(_) => OptionalKind::StdOption,
                    DefaultValueGenerator::FillDefaults => OptionalKind::GeneratedOptional,
                });

                let maybe_ampersand = if is_first {
                    is_first = false;

                    TokenStream::new()
                } else {
                    quote! { && }
                };

                quote! {
                    #maybe_ampersand self.#ident #method_call
                }
            })
            .collect()
    }

    /// Generates a conversions between [`Self::ident`] and [`Self::optional_ident`].
    ///
    /// - Generates a [`From`] conversion for [`Self::optional_ident`] that just calls [`Into::into`] on
    ///   [`Self::ident`], which wrap it in [`Some`] (or calls that type's implementation of the method).
    /// - Generates a method called `fill_defaults` on [`Self::optional_ident`] that fills [`None`] fields with the
    ///   value generated by each field's [`DefaultEqExpr::expr`] (or that type's implementation of the method).
    /// - Generates a method called `or` on [`Self::optional_ident`] calls [`Option::or`] on each field (or that type's
    ///   implementation of the method).
    /// - Generates a method called `xor` on [`Self::optional_ident`] calls [`Option::xor`] on each field (or that
    ///   type's implementation of the method). It is hard to imagine a use case for this, so it will probably be
    ///   removed eventually.
    /// - Generates a method called `is_all_some` on [`Self::optional_ident`] calls [`Option::is_some`] on each field
    ///   (or that type's implementation of the method).
    /// - Generates a method called `is_all_none` on [`Self::optional_ident`] calls [`Option::is_none`] on each field
    ///   (or that type's implementation of the method).
    #[must_use]
    pub fn generate_conversions(&self) -> TokenStream {
        let Self { ident, optional_ident, fields } = self;

        let idents = fields.iter().map(|FieldWithDefault { ident, .. }| ident).collect::<Vec<_>>();
        let assign_with_filled_defaults =
            fields.iter().map(FieldWithDefault::generate_assignment_with_filled_default).collect::<Vec<_>>();

        let is_all_some_comparisons = self.generate_field_comparisons(|optional_kind| match optional_kind {
            OptionalKind::StdOption => quote! { .is_some() },
            OptionalKind::GeneratedOptional => quote! { .is_all_some() },
        });
        let is_all_none_comparisons = self.generate_field_comparisons(|optional_kind| match optional_kind {
            OptionalKind::StdOption => quote! { .is_none() },
            OptionalKind::GeneratedOptional => quote! { .is_all_none() },
        });

        quote! {
            impl ::std::convert::From<#ident> for #optional_ident {
                fn from(value: #ident) -> Self {
                    Self {
                        // Some field of type `Type`, this has two effects. For `Option<Type>`,
                        // this will be `Option::from(Type)`, which is just `Some(Type)`. For
                        // `OptionalType`, this will be `OptionalType::from(Type)`, which should be
                        // calling _this_ method as it was generated for `OptionalType`.
                        #( #idents: value.#idents.into() ),*
                    }
                }
            }

            impl #optional_ident {
                #[doc = ::std::concat!(
                    "Create a new [`",
                    ::std::stringify!( #ident ),
                    "`] by filling all [`None`][`::std::option::Option::None`] values with the provided default expression.",
                )]
                #[must_use]
                pub fn fill_defaults(self) -> #ident {
                    #ident {
                        #( #assign_with_filled_defaults ),*
                    }
                }

                /// Apply [`Option::or`][`::std::option::Option::or`] or [`Self::or`] to each field of [`Self`].
                #[must_use]
                pub fn or(self, optb: Self) -> Self {
                    Self {
                        #( #idents: self.#idents.or(optb.#idents) ),*
                    }
                }

                /// Apply [`Option::xor`][`::std::option::Option::xor`] or [`Self::xor`] to each field of [`Self`].
                #[must_use]
                pub fn xor(self, optb: Self) -> Self {
                    Self {
                        #( #idents: self.#idents.xor(optb.#idents) ),*
                    }
                }

                /// Returns `true` if all fields are [`Some`], `false` otherwise.
                ///
                /// A field being [`Some`] is determined by [`Option::is_some`][`::std::option::Option::is_some`] or
                /// [`Self::is_all_some`].
                ///
                /// [`Some`]: `::std::option::Option::Some`
                #[must_use]
                pub fn is_all_some(&self) -> bool {
                    #( #is_all_some_comparisons )*
                }

                /// Returns `true` if all fields are [`None`], `false` otherwise.
                ///
                /// A field being [`None`] is determined by [`Option::is_none`][`::std::option::Option::is_none`] or
                /// [`Self::is_all_none`].
                ///
                /// [`None`]: `::std::option::Option::None`
                #[must_use]
                pub fn is_all_none(&self) -> bool {
                    #( #is_all_none_comparisons )*
                }
            }
        }
    }
}

/// The particular manner in which a field is "optional."
enum OptionalKind {
    /// A field that is "optional" by being [`Option`].
    StdOption,
    /// A field that is "optional" by having [`#[optional]`][`macro@crate::optional`] applied to it.
    GeneratedOptional,
}

/// Represents the two ways a value call have its default value filled.
enum DefaultValueGenerator {
    /// An expression that generates a default value for a field, can be used in the form
    /// `optional_field.unwrap_or_else(|| #expr)`.
    ///
    /// Is either [`Default::default`] or a caller-provided expression (see [`DefaultEqExpr::expr`]).
    Expr(Expr),
    /// An indication a default value for a field can be generated from some `optional_field` with
    /// `optional_field.fill_defaults()`.
    ///
    /// Comes from `#[option(flatten)]`.
    FillDefaults,
}

/// Represents a [`Field`] and an expression that generates a default value for it.
pub struct FieldWithDefault {
    /// See [`Field::ident`].
    ident: Ident,
    /// The expression that actually generates a default value.
    default: DefaultValueGenerator,
}

impl FieldWithDefault {
    /// Create a new [`Self`] from an arbitrary [`Field`].
    ///
    /// # Errors
    ///
    /// Returns an error if the provided [`Field`]:
    ///
    /// - Is a field on a tuple struct (i.e., if [`Field::ident`] is [`None`]).
    /// - Does not have the `#[option(...)]` annotation.
    /// - Has the `#[option(...)]` annotation, but it is malformed.
    pub fn new(field: &Field) -> Result<Self> {
        let option_attr_path = super::attr_paths::option();
        let Some(mut option_attr) = field.attrs.iter().find(|attr| attr.path() == &option_attr_path).cloned() else {
            return Err(Error::new(field.span(), "missing `#[option(...)]` annotation to provide default values"));
        };

        let Some(ident) = field.ident.clone() else {
            return Err(Error::new(field.span(), "`optional` does not support tuple structs"));
        };

        let default: DefaultValueGenerator = match &mut option_attr.meta {
            // Of the form `#[option(default = "STRING LITERAL")]`.
            Meta::NameValue(meta_name_value) => DefaultValueGenerator::Expr(meta_name_value.value.clone()),
            Meta::List(list) => {
                match list.tokens.to_string().as_str() {
                    // Of the form `#[option(default)]`.
                    "default" => DefaultValueGenerator::Expr(syn::parse_quote! { ::std::default::Default::default() }),
                    // Of the form `#[option(flatten)]`.
                    "flatten" => DefaultValueGenerator::FillDefaults,
                    // Of the form `#[option(default = EXPRESSION)]`.
                    _ => {
                        let DefaultEqExpr { expr, .. } = syn::parse(list.tokens.clone().into()).map_err(|_| {
                            Error::new(
                                field.span(),
                                "expected annotation in the form of `#[option(default)]`, `#[option(default = \
                                 EXPRESSION)]`, or `#[option(flatten)]",
                            )
                        })?;

                        DefaultValueGenerator::Expr(expr)
                    }
                }
            }
            // Of another form.
            other @ Meta::Path(_) => {
                return Err(Error::new(
                    other.span(),
                    "expected annotation in the form of `#[option(default)]`, `#[option(default = EXPRESSION)]`, or \
                     `#[option(flatten)]`",
                ));
            }
        };

        Ok(Self { ident, default })
    }

    /// Generate the actual assignment of this field in the struct instantiation using the provided default value. This
    /// does not include a trailing comma.
    ///
    /// Specifically, this generates a
    /// [`StructExprField`](https://doc.rust-lang.org/reference/expressions/struct-expr.html#grammar-StructExprField).
    #[must_use]
    fn generate_assignment_with_filled_default(&self) -> TokenStream {
        let Self { ident, default } = self;
        let method = match default {
            DefaultValueGenerator::Expr(expr) => quote! { .unwrap_or_else(|| #expr) },
            DefaultValueGenerator::FillDefaults => quote! { .fill_defaults() },
        };

        quote! {
            #ident: self.#ident #method
        }
    }
}

/// Transforms the input [`Fields`] for use in the optional struct.
///
/// - Strips all [annotations][`syn::Attribute`]. If `#[option(default ...)]` was present at all, this adds
///   `#[serde(default, skip_serializing_if = "::std::option::Option::is_none")]` (fields default to [`None`], the
///   actual default values are filled later).
/// - Changes the types from various `T` to `Option<T>`. This is _specifically_ `Option`, and not
///   `::std::option::Option`, because Clap finds optional fields by checking for [`Option`] on a strictly textual
///   basis.
///   - If `#[option(flatten)]` was present, this will treat make the field "optional" by instead renaming the
///     identifier `IDENT` to `OptionalIDENT`, e.g., the optional form of `::my_other_crate::Settings` is assumed to be
///     `::my_other_crate::OptionalSettings`, and there is assumed to be a method
///     `::my_other_crate::OptionalSettings::fill_defaults(&self) -> ::my_other_crate::Settings`.
///
/// # Errors
///
/// Returns an error if:
///
/// - The struct is a unit or tuple struct (i.e., if it is not a [`Fields::Named`]).
/// - If a field annotated with `#[option(flatten)]` has a [`Type`] that is not a [`Type::Path`] or a [`Type::Group`],
///   [`Type::Paren`], [`Type::Ptr`], or [`Type::Reference`] that contains a [`Type::Path`].
pub fn fields_to_optional(fields: Fields) -> Result<FieldsNamed> {
    match fields {
        Fields::Named(FieldsNamed { brace_token, named }) => {
            Ok(FieldsNamed { brace_token, named: named.into_iter().map(field_to_optional).collect::<Result<_>>()? })
        }
        Fields::Unnamed(_) => Err(Error::new(fields.span(), "`#[optional]` does not support tuple structs")),
        Fields::Unit => Err(Error::new(fields.span(), "`#[optional]` does not support unit structs")),
    }
}

/// Transforms a single input [`Field`] for use in the optional struct.
///
/// - If `#[option(flatten)]` was used:
///     - Change the field's type from some type `::path::to::Type` to `::path::to::OptionalType`.
///     - Replace the [annotation] with `#[command(flatten)]`.
///     - Append the [annotation] `#[serde(default, skip_serializing_if = "<::path::to::OptionalType>::is_all_none")]`.
/// - Otherwise:
///   - Changes the type from some `::path::to::Type` to `Option<::path::to::Type>`. This is _specifically_ `Option`,
///     and not `::std::option::Option`, because Clap finds optional fields by checking for [`Option`] on a strictly
///     textual basis.
///   - Replace the `#[option]` [annotation] with `#[serde(default, skip_serializing_if =
///     "::std::option::Option::is_none")]`.
///
/// In both cases, the field's value default to the equivalent of [`None`] when deserializing.
///
/// # Errors
///
/// Returns an error if a field annotated with `#[option(flatten)]` has a [`Type`] that is not a [`Type::Path`] or a
/// [`Type::Group`], [`Type::Paren`], [`Type::Ptr`], or [`Type::Reference`] that contains a [`Type::Path`].
///
/// [annotation]: `syn::Attribute`
fn field_to_optional(
    Field { mut attrs, vis, mutability, ident, colon_token, ty: mut input_ty }: Field,
) -> Result<Field> {
    let mut is_flattened_subcommand = false;

    let option_attr_path = super::attr_paths::option();
    if let Some(option_attr) = attrs.iter_mut().find(|attr| attr.path() == &option_attr_path) {
        if let Meta::List(ref mut list) = option_attr.meta
            && list.tokens.to_string() == "flatten"
        {
            is_flattened_subcommand = true;
            list.path = super::attr_paths::command();
        } else {
            *option_attr = syn::parse_quote! {
                #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            };
        }
    }

    let ty = if is_flattened_subcommand {
        self::rename_to_optional(&mut input_ty)?;

        let is_all_none = format!("<{}>::is_all_none", input_ty.to_token_stream());
        attrs.push(syn::parse_quote! {
            #[serde(default, skip_serializing_if = #is_all_none)]
        });

        input_ty
    } else {
        Type::Path(syn::parse_quote! {
            // This must be `Option<T>`, not `::std::option::Option<T>`, because Clap currently matches on `Option` (to
            // infer that an argument is optional) on a strictly textual basis, it doesn't attempt to infer from the
            // actual type.
            //
            // See:
            //
            // - <https://github.com/clap-rs/clap/issues/4636#issuecomment-1381969663>
            // - <https://github.com/clap-rs/clap/issues/4626>
            Option< #input_ty >
        })
    };

    Ok(Field { attrs, vis, mutability, ident, colon_token, ty })
}

/// Attempts to resolve the [`TypePath`] in `ty` and prepend `Optional` to the last segment.
///
/// E.g., `::path::to::Type` becomes `::path::to::OptionalType`.
///
/// # Errors
///
/// Will edit the [`TypePath`] that is internal to a [`Type::Path`], [`Type::Group`], [`Type::Paren`], [`Type::Ptr`], or
/// [`Type::Reference`]. An error will be returned if the type is of any other kind, including if it is any of the
/// latter four but does not contain a [`TypePath`]
fn rename_to_optional(ty: &mut Type) -> Result<()> {
    fn rename_path_to_optional(type_path: &mut TypePath) {
        let Some(last) = type_path.path.segments.last_mut() else {
            unreachable!("type paths must have at least one segment <https://doc.rust-lang.org/reference/paths.html#paths-in-types>");
        };

        let Ok(prefixed) = syn::parse_str(&format!("Optional{}", last.ident)) else {
            unreachable!("`Optional` + `MyValidIdent` = `OptionalMyValidIdent` should be valid");
        };
        last.ident = prefixed;
    }

    match ty {
        Type::Path(type_path) => rename_path_to_optional(type_path),
        Type::Group(type_group) => self::rename_to_optional(type_group.elem.as_mut())?,
        Type::Paren(type_paren) => self::rename_to_optional(type_paren.elem.as_mut())?,
        Type::Ptr(type_ptr) => self::rename_to_optional(type_ptr.elem.as_mut())?,
        Type::Reference(type_reference) => self::rename_to_optional(type_reference.elem.as_mut())?,
        Type::Array(_)
        | Type::BareFn(_)
        | Type::ImplTrait(_)
        | Type::Infer(_)
        | Type::Macro(_)
        | Type::Never(_)
        | Type::Slice(_)
        | Type::TraitObject(_)
        | Type::Tuple(_)
        | Type::Verbatim(_)
        | _ => {
            return Err(Error::new(
                ty.span(),
                "`#[option(flatten)]` can only flatten type paths or type groups, parenthesized types, pointers, or \
                 references that contain type paths",
            ));
        }
    }

    Ok(())
}
